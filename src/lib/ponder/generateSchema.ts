import type { Abi } from 'viem';

import { safeWriteFileSync } from '../utils/safeWrite.js';
import { validateEventParameters } from '../utils/validateEventParameters.js';
import type { ZonderConfig } from '../zonder/types.js';
import { solidityTypeToPgType } from './solidityTypeToPgType.js';

export function generateSchema<
  TChains extends Record<string, any>,
  TContracts extends Record<string, Abi>,
>(configOrContracts: ZonderConfig<TChains, TContracts> | Record<string, Abi>) {
  // Handle both full config and just contracts
  const contracts =
    'contracts' in configOrContracts ? configOrContracts.contracts : configOrContracts;
  const autogenerated = `// This file is auto-generated by zonder. Do not edit manually.\n`;
  const imports = `import { index, onchainTable } from 'ponder';\n`;

  const metadataSchema = `const metadataSchema = (t: any) => {
  return {
    id: t.text().primaryKey(),
    chainId: t.integer().notNull(),
    txHash: t.hex().notNull(),
    blockNumber: t.bigint().notNull(),
    blockTimestamp: t.bigint().notNull(),
    logIndex: t.integer().notNull(),
    logAddress: t.hex().notNull(),
  };
};`;

  let eventTables = ``;
  Object.entries(contracts).forEach(([contractName, abi]) => {
    const events = abi.filter((e: any) => e.type === 'event');
    if (!events.length) return;

    // Filter out anonymous events and validate remaining events
    const validEvents = events.filter((event: any) => {
      const isValidEvent = validateEventParameters(event, contractName);
      return isValidEvent;
    });

    if (!validEvents.length) return;

    eventTables += `\nexport const ${contractName} = {`;

    validEvents.forEach((event: any) => {
      const tableName = `${contractName}_${event.name}`;
      const eventArgs = event.inputs
        .map(
          (input: any) =>
            `   evt_${input.name}: t.${solidityTypeToPgType(input.type)}().notNull(),`,
        )
        .join('\n');
      const addressIndexes = event.inputs
        .filter((input: any) => input.type === 'address')
        .map(
          (input: any) =>
            `   evt_${input.name}Idx: index().using('btree', t.chainId, t.evt_${input.name}),`,
        )
        .join('\n');
      eventTables += `
  ${event.name}: onchainTable(\'${tableName}\', (t) => ({
    ...metadataSchema(t),
${eventArgs}
  }),
  (t) => ({
    chainIdBlockTimestampIdx: index().using('btree', t.chainId, t.blockTimestamp),
${addressIndexes}
  })),`;
    });
    eventTables += `\n};\n\n`;
    validEvents.forEach(
      (event: any) =>
        (eventTables += `export const ${contractName}_${event.name} = ${contractName}.${event.name};\n`),
    );
  });

  return `${autogenerated}\n${imports}\n${metadataSchema}\n${eventTables}`;
}

// Script wrapper for CLI usage
export function generateAndWriteSchema<
  TChains extends Record<string, any>,
  TContracts extends Record<string, Abi>,
>(config: ZonderConfig<TChains, TContracts>, outputPath = 'ponder.schema.ts', overwrite = false) {
  const schemaContent = generateSchema(config);
  safeWriteFileSync(outputPath, schemaContent, { overwrite });
}
